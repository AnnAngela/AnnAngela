"use strict";
const child_process = require("child_process");
const fsPromises = require("fs/promises");
const path = require("path");
const fixZero = (n, l = 2) => {
    let r = `${n}`;
    while (r.length < l) {
        r = `0${r}`;
    }
    return r;
};
const toLocalTimeZoneStrings = (date = new Date()) => `${date.getFullYear()}-${fixZero(date.getMonth() + 1)}-${fixZero(date.getDate())}T${fixZero(date.getHours())}:${fixZero(date.getMinutes())}:${fixZero(date.getSeconds())}.${fixZero(date.getMilliseconds(), 3)}+${fixZero(Math.floor(-date.getTimezoneOffset() / 60))}:${fixZero(-date.getTimezoneOffset() % 60)}`;
const c = {
    info: (...args) => console.info(toLocalTimeZoneStrings(), ...args),
    error: (...args) => console.error(toLocalTimeZoneStrings(), ...args),
};
/**
 * @param {string} cmd 
 * @param {boolean} [noerror=false] 
 * @returns {Promise<string, { error: any, stdout: string, stderr: string}>}
 */
const exec = (cmd, noerror = false) => new Promise((res, rej) => {
    c.info("[cmd]", cmd);
    child_process.exec(cmd, {
        cwd: "/",
    }, (error, stdout, stderr) => {
        if (!error || noerror && stdout.trim()) {
            const result = stdout.trim() || stderr.trim();
            c.info("[cmd-result]", result);
            res(result);
        } else {
            const result = {
                error, stdout: stdout.trim(), stderr: stderr.trim(),
            };
            c.error("[cmd-error]", result);
            rej(result);
        }
    });
});
c.info("Preparing");
exec("whereis n").then(async (step1) => {
    if (step1.length === 2) {
        c.info("Not initialize, run it");
        await exec('DEBIAN_FRONTEND=noninteractive DEBIAN_PRIORITY=critical apt install -y -o "Dpkg::Options::=--force-confold" curl wget ca-certificates nano git libpam-systemd- ; apt autoremove --purge -y ; wget https://raw.githubusercontent.com/tj/n/master/bin/n -O /tmp/n ; N_PRESERVE_NPM=1 bash /tmp/n lts ; rm /tmp/n ; npm install npm n --location=global');
        c.info("Successfully initialized");
    } else {
        const ltsVersion = await exec("n --lts");
        const localVersion = process.versions.node;
        if (ltsVersion !== localVersion) {
            c.info("Node outdated, update it");
            await exec("N_PRESERVE_NPM=1 n lts");
            c.info("Successfully updated");
        }
        const npmGlobalOutdatedList = Object.keys(JSON.parse(await exec("npm outdated --location=global --json", true)));
        if (npmGlobalOutdatedList.length > 0) {
            c.info("npm global outdated, update it");
            await exec("npm update --location=global");
            c.info("Successfully updated");
        }
    }
    const ex = "export N_PRESERVE_NPM=1";
    for (const base of ["/root", "~"]) {
        const bashrc = path.join(base, ".bashrc");
        c.info("Read", bashrc);
        const content = await fsPromises.readFile(bashrc, "utf-8");
        if (!content.includes(ex)) {
            c.info("No N_PRESERVE_NPM, add it to", bashrc);
            await fsPromises.writeFile(bashrc, `${content}\n\n${ex}`);
            c.info("Successfully added N_PRESERVE_NPM to", bashrc);
        } else {
            c.info("Already have N_PRESERVE_NPM in", bashrc);
        }
    }
}).catch((e) => {
    c.error("[Error]", e);
});
